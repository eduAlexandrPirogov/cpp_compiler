# Линковка

После компиляции **cpp** файлов, наступает этап линковки. Обычно программа разбита на несколько файлов и после компиляции у нас появляются несколько файлов **.obj**. Чтобы преобразовать объектные файлы **.obj** в исполняемый код, в дело вступает линкер.

Основная функция линкера (Linker) -- найти, где находится **определение** каждого символа, каждой функции и т.п.,а также находит **entry point** вашей программы.

Выглядит примерно все следующим образом:

```

a.cpp------>|->a.obj-->|
                       |
b.h-------->|          |
            |->b.obj-->|
            |          |
b.cpp------>|          |--->LINKER---->executable program
                       | 
c.h-------->|          |
            |->c.obj-->|
c.cpp------>|
```

## Объявления и определения

Вспомним разницу между объявлением и определением.

`declare_definition/declare_definition.cpp`

```cpp
int x; //declare
extern int y; //non-definition declare

void f(int x); //declare

int main()
{
   x = 10; //definition
   y = 20; //definition
  // f(50); Linker error! Not compile!
};
```

Переменные **x**, **y** и функция **void f(int x)** за пределами функции **main** -- объявлены. Мы говорим компилятору, мол "мы объявили это, а определения лежат где-то за пределами". Иначе говоря, мы создали переменные, но не выделили на них память (haven't allocate em).

Далее, в функции **main** определяем переменные **x** и **у**, но не определяем функция **void f(int x)**. 

При этом, компиляция выполнится успешно (если мы расскоменитруем f(50)). Но проект не соберется, так как Линкер не найдет определение для данной функции!

Рассмотрим следующий пример. Имеем два файла 
`main.cpp`
```cpp
//void Log(const char* message, int x);

int main()
{
   int x = 10;
   Log("Hello, world\n", x);
   return 0;
};
```

`log.cpp`
```cpp
#include <iostream>

void Log(const char* message, int x)
{
   std::cout << message << "\nx = " << x << '\n';
};
```

Имеется функция **Log(const char* message, int x)**, которая расположена в `log.cpp` файле. Поскольку в `main.cpp` закомментировано объявление данной функции, 
компилятор выдаст ошибку компилятора **log wasn't declared in this scope**. Стоит добавить объявление функции (раскомментировать объявление в `main.cpp`), и проблема решится. Работает все по такой же схеме: создаются два объектных файла `log.o` и `main.o`,и далее линкер преобразует объектные файлы в исполняемый файл.  :)
.

## Header файлы

Рассмотрим ещё один пример с **header** файлами. Обычно, header-файлы хранят в себе объявление переменных, функций и т.д.

Как мы помним, препроцессор включает содержимое header-файлов в файл, содержащий соответствующую **#include** директиву.

Тут стоит сказать о нескольких важных моментах:

### ODR rule

**One definition rule** -- translation units defines entity exactly one time.
 
Каждый объектный файл определяет сущность лишь единжды.

Линкер может столкнуться со следующими проблемами:
1. undefined reference
2. multiple references

Undefined reference говорит, что линкер не может найти определения для некоторой сущности. Пример:

```cpp
```


```cpp
```
